import * as core from '@actions/core';
import { Octokit } from '@octokit/rest';
import {
  CompatibilityReport,
  CompatibilityResult,
  GITHUB_MARKERS,
  STATUS_EMOJIS,
  BaselineStatus,
  getPolyfillSuggestion,
  formatPolyfillSuggestion,
  githubCache,
  getPRDiffCacheKey,
  GitHubAPIError,
} from './shared';

/**
 * Get the Octokit instance for GitHub API
 */
export function getOctokit(token: string): Octokit {
  return new Octokit({ auth: token });
}

/**
 * Get PR diff content (with caching and error handling)
 */
export async function getPRDiff(
  octokit: Octokit,
  owner: string,
  repo: string,
  pullNumber: number
): Promise<string> {
  try {
    // Check cache first
    const cacheKey = getPRDiffCacheKey(owner, repo, pullNumber);
    const cached = githubCache.get(cacheKey);

    if (cached !== undefined) {
      core.info(`Using cached diff for PR #${pullNumber}`);
      return cached;
    }

    core.info(`Fetching diff for PR #${pullNumber}...`);
    const { data } = await octokit.rest.pulls.get({
      owner,
      repo,
      pull_number: pullNumber,
      mediaType: {
        format: 'diff',
      },
    });

    const diffContent = data as unknown as string;

    // Cache the result (10 minute TTL)
    githubCache.set(cacheKey, diffContent, 600);

    return diffContent;
  } catch (error: any) {
    const statusCode = error?.status || error?.response?.status;
    const message = error?.message || 'Unknown error';

    core.error(`Failed to fetch PR diff: ${message}`);

    throw new GitHubAPIError(
      `Failed to fetch PR #${pullNumber} diff: ${message}`,
      statusCode,
      { owner, repo, pullNumber }
    );
  }
}

/**
 * Format compatibility report as markdown comment
 */
export function formatComment(report: CompatibilityReport): string {
  const { results, score, blockingCount, warningCount, totalFeatures } = report;

  let comment = `${GITHUB_MARKERS.COMMENT_HEADER}\n\n`;
  comment += `# ${GITHUB_MARKERS.COMMENT_TITLE}\n\n`;

  // Overall score with progress bar
  const scoreEmoji = score >= 90 ? '🟢' : score >= 70 ? '🟡' : '🔴';
  const progressBar = generateProgressBar(score);
  comment += `## Compatibility Score: ${scoreEmoji} **${score}/100**\n\n`;
  comment += `${progressBar}\n\n`;

  // Summary table
  comment += `| Metric | Count | Status |\n`;
  comment += `|--------|-------|--------|\n`;
  comment += `| Features Detected | ${totalFeatures} | ℹ️ |\n`;
  comment += `| Blocking Issues | ${blockingCount} | ${blockingCount > 0 ? '❌' : '✅'} |\n`;
  comment += `| Warnings | ${warningCount} | ${warningCount > 0 ? '⚠️' : '✅'} |\n`;
  comment += `| Safe to Use | ${report.infoCount} | ✅ |\n\n`;

  if (results.length === 0) {
    comment += `> ✅ **Great news!** No web features detected in this PR that require compatibility checking.\n\n`;
    comment += `This PR doesn't introduce any new web platform features that need baseline validation.\n`;
    return (
      comment +
      `\n---\n🤖 *Powered by [GreenLightCI](https://github.com/your-org/greenlightci)*\n`
    );
  }

  // Group results by severity
  const blocking = results.filter((r: CompatibilityResult) => r.blocking);
  const warnings = results.filter(
    (r: CompatibilityResult) => r.severity === 'warning' && !r.blocking
  );
  const info = results.filter(
    (r: CompatibilityResult) => r.severity === 'info'
  );

  // Blocking issues with action items
  if (blocking.length > 0) {
    comment += `## ❌ Blocking Issues\n\n`;
    comment += `> **Action Required:** The following features need attention before merging.\n\n`;

    for (const result of blocking) {
      comment += formatFeatureResult(result);
    }
  }

  // Warnings with recommendations
  if (warnings.length > 0) {
    comment += `## ⚠️ Warnings\n\n`;
    comment += `> **Recommendation:** These features are newly available. Consider adding polyfills for broader support.\n\n`;

    for (const result of warnings) {
      comment += formatFeatureResult(result);
    }
  }

  // Info - collapsible for cleaner view
  if (info.length > 0) {
    comment += `## ✅ Safe to Use\n\n`;
    comment += `<details>\n<summary><b>View ${info.length} widely available feature${info.length > 1 ? 's' : ''}</b> (click to expand)</summary>\n\n`;

    for (const result of info) {
      comment += formatFeatureResult(result);
    }

    comment += `</details>\n\n`;
  }

  comment += `---\n`;
  comment += `\n### 📚 Resources\n\n`;
  comment += `- [Baseline Documentation](https://web.dev/baseline/)\n`;
  comment += `- [Browser Compatibility Data](https://github.com/mdn/browser-compat-data)\n`;
  comment += `- [Can I Use](https://caniuse.com/)\n\n`;
  comment += `<sub>🤖 Generated by [GreenLightCI](https://github.com/your-org/greenlightci) | Need help? [Open an issue](https://github.com/your-org/greenlightci/issues)</sub>\n`;

  return comment;
}

/**
 * Generate a visual progress bar for the score
 */
function generateProgressBar(score: number): string {
  const filled = Math.floor(score / 5); // 20 blocks for 100%
  const empty = 20 - filled;
  const bar = '█'.repeat(filled) + '░'.repeat(empty);
  return `\`${bar}\` ${score}%`;
}

/**
 * Format individual feature result
 */
function formatFeatureResult(result: CompatibilityResult): string {
  const { feature, filePath, line } = result;
  const statusEmoji = getStatusEmoji(feature.status);

  let output = `#### ${statusEmoji} \`${feature.name}\`\n\n`;

  // Status badge with color
  const statusBadge = getStatusBadge(feature.status, feature.baselineYear);
  output += `${statusBadge}\n\n`;

  output += `- **Location:** \`${filePath}\``;
  if (line) {
    output += `:${line}`;
  }
  output += `\n`;

  // Browser support
  if (Object.keys(feature.support).length > 0) {
    output += `- **Browser Support:** `;
    const supportList: string[] = [];
    if (feature.support.chrome)
      supportList.push(`Chrome ${feature.support.chrome}+`);
    if (feature.support.edge) supportList.push(`Edge ${feature.support.edge}+`);
    if (feature.support.firefox)
      supportList.push(`Firefox ${feature.support.firefox}+`);
    if (feature.support.safari)
      supportList.push(`Safari ${feature.support.safari}+`);
    output += supportList.join(' • ') + `\n`;
  }

  // Polyfill suggestions for non-widely-available features
  if (
    feature.status !== BaselineStatus.WidelyAvailable &&
    result.severity !== 'info'
  ) {
    const polyfill = getPolyfillSuggestion(feature.id);
    if (polyfill) {
      output += `\n<details>\n<summary>💡 <b>Polyfill & Fallback Options</b></summary>\n\n`;
      output += formatPolyfillSuggestion(polyfill);
      output += `</details>\n`;
    }
  }

  // Links
  if (feature.mdnUrl) {
    output += `\n📖 [View on MDN](${feature.mdnUrl})`;
  }
  if (feature.specUrl) {
    output += ` • [Specification](${feature.specUrl})`;
  }

  output += `\n\n`;
  return output;
}

/**
 * Get status badge with color
 */
function getStatusBadge(status: BaselineStatus, year?: string): string {
  switch (status) {
    case BaselineStatus.WidelyAvailable:
      return `![Widely Available](https://img.shields.io/badge/Baseline-Widely%20Available${year ? `%20(${year})` : ''}-brightgreen)`;
    case BaselineStatus.NewlyAvailable:
      return `![Newly Available](https://img.shields.io/badge/Baseline-Newly%20Available${year ? `%20(${year})` : ''}-yellow)`;
    case BaselineStatus.Limited:
      return `![Limited](https://img.shields.io/badge/Baseline-Limited%20Availability-orange)`;
    case BaselineStatus.NotBaseline:
      return `![Not Baseline](https://img.shields.io/badge/Status-Not%20Baseline-red)`;
    default:
      return `![Unknown](https://img.shields.io/badge/Status-Unknown-lightgrey)`;
  }
}

/**
 * Get emoji for baseline status
 */
function getStatusEmoji(status: BaselineStatus): string {
  switch (status) {
    case BaselineStatus.WidelyAvailable:
      return STATUS_EMOJIS.WIDELY_AVAILABLE;
    case BaselineStatus.NewlyAvailable:
      return STATUS_EMOJIS.NEWLY_AVAILABLE;
    case BaselineStatus.Limited:
      return STATUS_EMOJIS.LIMITED;
    case BaselineStatus.NotBaseline:
      return STATUS_EMOJIS.NOT_BASELINE;
    default:
      return STATUS_EMOJIS.UNKNOWN;
  }
}

/**
 * Post or update comment on PR (with enhanced error handling)
 */
export async function postComment(
  octokit: Octokit,
  owner: string,
  repo: string,
  pullNumber: number,
  body: string
): Promise<void> {
  try {
    core.info('Posting compatibility report to PR...');

    // Check if we already have a comment
    const { data: comments } = await octokit.rest.issues.listComments({
      owner,
      repo,
      issue_number: pullNumber,
    });

    const existingComment = comments.find((comment) =>
      comment.body?.includes(GITHUB_MARKERS.COMMENT_HEADER)
    );

    if (existingComment) {
      // Update existing comment
      await octokit.rest.issues.updateComment({
        owner,
        repo,
        comment_id: existingComment.id,
        body,
      });
      core.info(
        `✓ Updated existing compatibility comment (ID: ${existingComment.id})`
      );
    } else {
      // Create new comment
      const { data: newComment } = await octokit.rest.issues.createComment({
        owner,
        repo,
        issue_number: pullNumber,
        body,
      });
      core.info(`✓ Created new compatibility comment (ID: ${newComment.id})`);
    }
  } catch (error: any) {
    const statusCode = error?.status || error?.response?.status;
    const message = error?.message || 'Unknown error';

    core.error(`Failed to post comment: ${message}`);

    throw new GitHubAPIError(
      `Failed to post comment on PR #${pullNumber}: ${message}`,
      statusCode,
      { owner, repo, pullNumber, commentLength: body.length }
    );
  }
}

/**
 * Set PR status check (with enhanced error handling)
 */
export async function setStatus(
  octokit: Octokit,
  owner: string,
  repo: string,
  sha: string,
  state: 'success' | 'failure' | 'pending',
  description: string
): Promise<void> {
  try {
    await octokit.rest.repos.createCommitStatus({
      owner,
      repo,
      sha,
      state,
      context: 'Baseline Compatibility',
      description,
      target_url: `https://github.com/${owner}/${repo}/actions`,
    });
    core.info(`✓ Set status to "${state}": ${description}`);
  } catch (error: any) {
    const statusCode = error?.status || error?.response?.status;
    const message = error?.message || 'Unknown error';

    // Don't fail the action if we can't set status, just warn
    core.warning(
      `Failed to set commit status: ${message} (status code: ${statusCode})`
    );
    core.warning(
      'This may happen if the GitHub token lacks status check permissions'
    );
  }
}
